\documentclass[a4paper, 10pt]{article}

%-------------------------- Packete ------------------------------------
\usepackage[german]{babel}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage[top=2cm, left=1.5cm, right=1.5cm, bottom=3cm]{geometry}
\usepackage{mathtools}

\usepackage{ marvosym }
%------------------------- Einstellungen -------------------------------
\setlength{\parindent}{0pt}
\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}
\addtolength{\headheight}{1\baselineskip}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
\newcommand{\bs}{\ensuremath{\backslash}}

\lstset{
inputencoding=utf8,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
%  numbers=left,
%  numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b,
literate={ö}{{\"o}}1 {ä}{{\"a}}1 {ü}{{\"u}}1 {°}{\dg}1 {»}{\frqq}1 {«}{\flqq}1 {ß}{\ss}1 {@}{\@}1 {Ä}{{\"A}}1
}
 
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

%
%Edit the Course, assignment number and members of your group here
%
\newcommand{\courseName}{Berechenbarkeit und Komplexität}

\newcommand{\assignmentNr}{BuK Zusammenfassung WS18/19}


\newcommand{\studentB}{\textbf{Luis Rickert} -- 318153}
\newcommand{\kleene}{\Sigma^*}
\newcommand{\bb}{$b:=b+1$}
\newcommand{\goedl}[1]{\langle {#1}\rangle}
%Left side of the Top header:
\fancyhead[L]{
	\textbf{\courseName}\\
	\assignmentNr{}
}

%Right side of the Top header:
\fancyhead[R]{
	\\	\studentB
}
\pagestyle{fancy}

\begin{document}
\small
\section{Einführung}
\subsection{Modellierung}
\begin{tabular}{l| l}
    $\epsilon$ & das leere Eingabe Wort\\
    \hline
    $\Sigma^0$ & Menge die nur das leere Wort enthält  \\
    \hline
    $\Sigma^k$ & Menge die alle Wörter der Länge k enthält\\
    \hline
    $\kleene$ & 'Kleenesche Abschluss' Menge die alle Wörter über $\Sigma$ enthalten\\
    \hline
    $\epsilon,0,1,00,01,11,000,001,010,011,100,101,\dots$&kanonische Aufzählung
\end{tabular}
\begin{itemize}
    \item Graphen über $\{0,1\}$ kodieren als Adjazenzmatrix
\end{itemize}
\subsection{Algorithmen}
\begin{itemize}
    \item verarbeiten Wörter schrittweise
    \item eindeutig festgelegt durch endlichen text
    \item zu jedem Algo. A mit Eingabe $w$ und Ausgabe $v$ wird eine funktion $f_A$ zugeordent mit $f_A(w)=v$
    \item terminiert $A$ nicht auf einder Eingabe, dann gilt für $f_A=$undefiniert sowie $f_A(w)=\perp$
\end{itemize}
\begin{definition}{Von Algorithmus berechnete Funktion }[Skript 1.6]\begin{itemize}
    \item Algorithms A, Eingabe $w$, Ausgabe $v$ wird funktion $f_A$ zugeordnet mit
    \item $f_A(w)=v$
    \item terminiert $A$ nicht auf $w$: \begin{itemize}
        \item $f_A(w)=$ undefiniert $\lor$
        \item $f_A(w)=\perp$
    \end{itemize}
\end{itemize}
\end{definition}
\begin{definition}{Berechenbare Funktionen }[Skript 1.7]
    \begin{itemize}
        \item Funktion $f$ mit Argumenten aus $M$\\
        $Def(f)=\{m\in M|f(m)\text{ ist definiert}\} \lor$\\
        $Def(f)=\{w\in\kleene|f(w)\neq\perp\}$\\
        'Definitionsbereich von $f$'\\
        $\rightarrow f$ bekommt seine Eingaben aus M, muss aber nicht auf allen definiert sein.
        \item $Bild(f)=\{n\in N|\exists m\in M:f(m)=n\}$\\
        'Bildbereich von $f$'
        \item $f:M\leadsto N$
    \end{itemize}
\end{definition}
\begin{definition}{Totale Funktion }[Skript 1.8]
\begin{itemize}
    \item Wie partielle Funktion nur das das gilt:
    \item $Def(f)=M,f:M\to N$
\end{itemize}
\end{definition}
\begin{definition}{Berechenbare Funktion }[Skript 1.10]\\
Eine Funktion $f:\kleene\leadsto\kleene$ heißt berechenbar gdw. es gibt einen Algorithmus $A$ der $f$ berechnet.
\end{definition}
\begin{definition}{Entscheibar }[Skript 1.12]\\
Sprache $L\subseteq \kleene$ heißt entscheidbar, wenn es einen Algorithmus gibt, der 'Ja' ausgibt wenn das Eingabewort $w$ L enthalten ist und 'Nein' wenn es nicht enthalten ist.
\end{definition}
\begin{definition}{Aufzählungsalgorithmen }[Skipt 1.13]\\
Aufzählungsalogrithmus $A$ startet auf $\epsilon$ und braucht nicht zu terminieren. Er gibt in irgenteiner Reihenfolge Wörter aus. Diese fasst man in der Menge $L_A$ zuammen.\\
Einge Menge von Wörtern oder Sprache L heißt aufzählbar wenn es  einen Aufzähler $A$ gibt mit $L=L_A$.\\ \\
 
$\Rightarrow$ \underline{aufzählbarkeit $\neq$ entscheidbarkeit ! }

\end{definition}\newpage
\subsection{Turingmaschinen}
$\rightarrow$ abstraktes Automatenmodell, entwickelt von Alan Turing, um die Durchführung beliebiger Algorithmen zur Symbolmanipulation präzise zu fassen.
\begin{definition}{Turingmaschine (TM)}[Skript 1.3.1]\\
\begin{itemize}
\item $Q $  endliche Zustandsmenge
\item $\Sigma\supseteq\{0,1\}$ endliche Eingabealphabe
\item $\Gamma\supset\Sigma$,  endliche Bandalphabet
\item $B\in\Gamma/\Sigma$, Leerzeichen (Blank)
\item $q_0\in Q$, Anfangszustand
\item $\bar{q}\in Q$, Stopp/Endzustand 
\item Zustandsübergangsfunktion:\begin{align*}
	\delta:(Q/\{\bar{q}\}\times\Gamma\to Q\times\Gamma\times\{R,L,N\}
\end{align*}
\item Alternative: Darstellung der übergangsfunktion in einer Tabelle, Spalten sind die Symbole des Eingabealphabet, die Zeilen die die möglichen Zustände. Der Endzustand kommt nur als Transitionsziel in den Zellen der Tabelle vor. In den Zellen stehen Tupel der Form $(Zustand,schreiben,richtung)$. D.h. wenn man im Zustand $q_i$ die Eingabe $e$ ließt führt man $(q_j,k,r)$ aus mit $k\in\Gamma\land r\in\{R,L,N\}$ .man wechselt in Zustand $q_j,$ überschreibt die gelesene Zelle mit $k$ und bewegt sich in die Richtug $r$.
\end{enumerate}
\paragraph{k-Spur TM} Eine TM mit k-Spuren, die Spuren stehen unter eineander mit einem Kopf, jedoch können sich die Köpfe nich getrennt von eineander bewegen. Hier wird das Bandalphabet um $k-$dimensionale Vektoren erweitern.
\paragraph{k-Band TM } Eine Tm mit k-Bändern, ähnlich wie k-Spur TM nur das sich die Köpfe unabhäning von einander bewegen können. Die übergangsfuntkion $\delta$ wird zu $\delta:(Q/\{\bar{q}\}\times\Gamma^k\to Q\times\Gamma^k\times\{L,R,N\}^k)$ erweitert. Band 1 ist das Eingabe/Ausgabe Band.\\
Eine TM $M$ mit Rechenzeit $t(n)$ und Platzbedarf $s(n)$ auskommt, kann von einer (1-Band) TM $M'$ mit Zeitbedarf $O(t^2(n))$ und Platzbedarf $O(s(n))$ simuliert werden.
\end{definition}

\subsubsection{Konfiguration}

\paragraph{Konfiguration}
\begin{itemize}
\item Ist ein String $\alpha q\beta$ ,wobei $q\in Q \land \alpha,\beta \in\Gamma^*\to$ man ist im Zustand $q$ und auf dem Band steht $\alpha\beta$ eingerahmt von Blanks.
\end{itemize}
\paragraph{direkte Nachfolgekonfiguration}
\begin{itemize}
\item $\alpha'q\beta'$ heißt \underline{direkte} Nachfolgekonfig. wenn aus $\alpha q\beta$ in  einem Rechenschritt $\alpha'q\beta'$ wird. $\to\alpha q'\beta \vdash \alpha'q\beta'$
\end{itemize}
\paragraph{Nachfolgekonfiguration}
\begin{itemize}
\item $\alpha'' q''\beta''$ heißt Nachfolgekonfiguration von $\alpha q\beta$ wenn $\alpha'' q''\beta''$ in endlich vielen Rechenschritten erreicht werden kann $\to\alpha q\beta \vdash \alpha''q''\beta''$
\end{itemize}
\paragraph{Nachvollziehen einer Berechnung}
Um eine Rechnung nachzuvollziehen gibt man eine Abfolge von Konfigurationen an. z.B.:\begin{align*}
q_00110\vdash 0q_0110\vdash 01q_1 10\vdash 011q_1 0\vdash 0110q_0 B \vdash 0110\bar{q}1 
\end{align*}
\paragraph{TM-Berechenbare Funktionen}
- TM die für jede Eingabe terminiert berechnet eine totale Funktion.
- Das die Ausgabe beginnt unter dem Lese/Schreibkopf und wird nach  rechts durch den ersten Buchstaben begrenzt der nicht im Bandalphabet ist.
Da die meisten TM nicht immer terminieren, berechnen im allegmeinen eine Funktion $F:M\leadsto N$.
\paragraph{TM-Berechenbarkeit, Rekursivität}
Eine funktion heißt TM-berechenbar oder rekursiv, wenn es eine TM gibt, die auf jeder Eingabe $w$ terminiert mit der Ausgabe $f(w)$ .
\paragraph{partiel rekursiv} Eine Funktion $f$ heißt paritell rekursiv, wenn es eine TM M gibt die, genau auf den Wörtern $w\in Def(w)$ terminiert mit der Ausgabe $f(w)$.
\begin{definition}{TM-Entscheibarkeit}[Skript 1.17]\\
Eine Sprache $L$ heißt TM-Entscheidbar oder rekursiv, wenn es eine TM $M$ gibt, die auf allen eingaben $w\in\kleene$ stoppt und die Eingabe $w$ genau dann akzeptiert, wenn $w\in L$ und die Eingabe verwirft wenn $w\not\in L$.
\end{definition}
\begin{definition}{Aufzählungs-Turingmaschine}[Skript 1.18]
\begin{itemize}
\item TM der Form $(Q,\Sigma,\Gamma,B,q_0,bar{q},q_{out},\delta)$
\item $q_{out}$ deints als Ausgabezustand für die einzelnen Wörter, das an Kopfposition beginnt und vor dem ersten Symbol aus $\Gamma /\Sigma$ endet.
\end{itemize}
Eine Sprache $L$ heißt rekursiv aufzählbar, wenn es eine Aufzähler gibt, der die Spache $L$ enthält
\end{definition}
\subsection{Registermaschine}
\begin{definition}{Registermaschine}[Skript 1.3.3]
RAM (Random Access Machine)\begin{itemize}
    \item hat unbeschränkte Anzahl an Registern $c(0),c(1),c(2),\dots,c(n)$
    \item Register $c(0)$ heißt Akkumulator, Rechnerbefehle nutzen dieses Register als implizites Argument, sowie als Speicherort für das Ergebnis von Rechenoperationen
    \item Inhalt der Register sind ganze Zahlen, beliebiger Größe
    \item der Befehlszähler $b$ wird mit $1$ initialisiert
    \item Ram durchläuft ein Programm das aus nummerierten Zeilen besteht, bei der Jede Zeile ein Befehl ist. $b+=1$ wenn der Befehl aus geführt wurde.
    \item ein Programm terminiert sobald der Befehl 'END' erreicht wird
    \item für die Laufzeitberechnung gibt es zwei Modelle:\begin{itemize}
        \item Uniformes Kostenmaß: Jeder Schritt ist eine Zeiteinheit
        \item Logarithmisches Kostenmaß: Laufzeikosten eines Schritts sind poportional zur binären Länge der Zahlen in den angesprochenen Registern 
        \item terminiert die Berechnung nicht, ist die Laufzeit unbeschränkt
    \end{itemize}
\end{itemize} 
\end{definition}
\begin{definition}{"minimales"-RAM-Modell:}[Skript 1.22]
URM-Programm hat die Form $1.instr_1,2.instr_2,\dots,k-1.instr_{k-1},k.end$ wobei jedes $instr_j,\quad j=1,\dots,k-1$ eines der folgenden 3 Typen sein kann.\begin{align}
    INC(X_i)=&\quad &(X_i:=X_i+1)\\
    DEC(X_i)=&\quad &(X_i:=X_i-1)\\
    IF X_i=& 0\quad GOTO &l(1\leq l\leq k)
\end{align}

\end{definition}
\subsubsection{Verlgeich TM vs. RAM}
Jede RAM deren Laufzeit durch $t(n)$ beschränkt ist, kann druch eine TM simuliert werden, die durch ein Polynom $O(q(n+t(n))$ beschränkt ist simuliert werden.[Skript Sat 1.23]\\ \\
Jede $t(n)$ Zeit beschränkte TM  kann durch eine RAM simuliert werden die uniform $O(t(n)+n)$ und logarithmisch \\$O((t(n)+n)log(t(n)+n))$ zeitbeschränkt ist.[Skropt Satz 1.26]

\subsubsection{RAM-Befehle}
\begin{tabular}{|l|l|c|}
    \hline
    Syntax & Zustandsänderung&Änderung von $b$  \\
    \hline
    LOAD $i$ &$c(0)=c(i)$ &\bb \\
    CLOAD $i$ & $c(0)=i$& \bb \\
    INDLOAD $i$&$c(0)=c(c(i))$&\bb\\
    \hline
    STORE $i$ &$c(i):=c(0)$&\bb\\
    INDSTORE $i$ & $c(c(i))=c(0)$&\bb\\
    \hline
    ADD $i$ & $c(0)=c(0)+c(i)$&\bb\\
    CADD $i$ & $c(0)=c(0)+i$&\bb\\
    INDADD $i$ & $c(0)=c(0)+c(c(i))$&\bb\\
    \hline
    SUB $i$ & $c(0)=c(0)\dot{-} c(i)$&\bb\\
    CSUB $i$ & $c(0)=c(0)\dot- i$&\bb\\
    INDSUB $i$ & $c(0)=c(0)\dot- c(c(i))$&\bb\\
    \hline
    MULT $i$ &$c(0)=c(0)\cdot c(i) $ & \bb\\
    CMULT $i$ & $c(0)=c(0)\cdot i$&\bb\\
    INDMLT $i$&$c(0)=c(0)\cdot c(c(i))$&\bb\\
    \hline
    DIV $i$ & $c(0)=\lfloor c(0)/c(i)\rlfoor$&\bb\\
    CDIV $i$ & $c(0)=\lfloor c(0)/i \rfloor$&\bb\\
    INDDIV $i$ &$c(0)=\lfloor c(0)/c(c(i))\rfloor$&\bb\\
    \hline
    GOTO $i$ &-&$b:=i$\\
    IF $c(0)=x$ GOTO $j$&-&$b:=\begin{cases}{j,\text{ falls }c(0)=x\\b+1 \text{ sonst}\end{cases}$\\
    IF $c(0)<x$ GOTO $j$&-&$b:=\begin{cases}j\text{ falls }c(0)<x\\b+1\text{ sonst}\end{cases}$\\
    IF $c(0)\leq x$ GOTO $j$&-&$b:=\begin{cases}j\text{ falls }c(0)\leq x\\b+1\text{ sonst}}\end{cases}$\\
    \hline
    END & ENDE der Rechnung& \\
    \hline
\end{tabular}\footnote{$n/0=0$ für Berechnungen in RAMs}\footnote{$c(0)\dot{-}c(i)=0\Longleftrightarrow c(0)\leq c(i)$}


\subsection{Zusammenfassung Kaptiel 1}
\begin{itemize}
\item eine Funktion ist berechenbar wenn es eine TM gibt, die sie berechnet
\item eine Funktion ist total, wenn sie für alle Möglichen Eingaben definiert ist $f:M\to N$
\item eine Funktion ist partiell, wenn sie für eine Teilmenge der möglichen Eingaben definiert ist $f:M\leadsto N$
\item eine Sprache ist rekursiv/berechenbar, wenn es eine TM gibt die sie entscheidet\begin{itemize}
\item $1\forall w \in L$
\item $0\forall w\not\in L$
\end{itemize}
\item eine Sprache ist paritell rekursiv, wenn es eine TM gibt die auf alle ihren Wörtern hält und diese akzeptiert\begin{itemize}
\item $f_M(w)=v\forall w\in L$
\item $f_M(w)=\perp\forall w\not\in L$ ($\perp\widehat{=}$terminiert nicht bzw nicht definiert)
\end{itemize}
\item eine Sprache ist aufzählbar(=rekursiv aufzählbar), wenn es einen Aufzähler für sie gibt
\item Register der RAM können beliebig große Ganze zahlen enthalten
\item \begin{itemize}
    \item uniformes Kostenmaß: jeder Schritt eine Zeiteinheit
    \item log Kostenmaß: Laufzeitkosten prop. zur bin. Länge der angesprochenen Register
\end{itemize}
\item jede RAM,$t(n)$ beschränkt, kann durch TM simluiert werden Laufzeit : $O(q(n+t(n))$ beschränkt,$p(k)$ polynom
\item jede TM,$t(n)$ beschränkt, kann druch eine RAM simuliert werden, 
\begin{itemize}
    \item uniform: $O(t(n)+n)$ 
    \item log: $O(t(n)+n)log(t(n)+n)$
\end{itemize}

\end{itemize}
\newpage
\section{Berechenbarkeit}
\subsection{Church-Turing-These} Die Klasse der Turing-berechenbaren Funktion stimmt mit der KLasse der intuitiv berechenbaren Funktionen überein.
\subsection{Berechenbarkeit, Aufzählbarkeit, Entscheidbarkeit}

Eine Menge $L\subseteq \kleene$ ist aufzählbar gdw. $Def(f)=L,\quad f:\kleene\leadsto\kleene$. "$L$ ist Definitionsbereich einer berechenbaren Funktion (es gibt eine TM die sie berechnet)"
\paragraph{Graph einer Funktion}
Funktion $f:\kleene\leadsto\kleene ,G_f=\{u\# v|u\in Def(f)\land f(u)=v\}\quad f$ ist genau dann berechenbar, wenn $G_f$ aufzählbar.
\paragraph{Satz 2.5} 
\subparagraph{a)}\boxed{ \text{Ist } $L\subseteq \kleene$ entscheidbar $\Rightarrow\quad L$ aufzählbar}
\subparagraph{b)} \boxed{$L\subseteq\kleene$ entscheibar gdw. $L$ aufzählbar  \underline{und} $\kleene/L$ aufzählbar}

\begin{definition}{semi-entscheibar}[Skript 2.6]
Eine Spreache $L\subseteq\kleene$ heißt semi-entscheidbar, wenn es eine TM $M$ über $\Sigma$ gibt, die:
\begin{align*}
    &\begin{rcases}\forall w&\in L \text{ terminiert } M \\ \forall w&\not\in L, M=\perp\end{rcases} = Aufzähbarkeit\\
    &\Rightarrow \boxed{L\in\kleene \text{ semi-entscheidbar }\Longleftrightarrow L \text{ aufzählbar}[\text{Skript Satz }2.7]}
\end{align*}

\end{definition}
\subsection{Halteproblem H}
Ein Problem ist nicht entcheidbar, dann gibt es keine Möglichkeit diese Problem zu berechnen!
\begin{definition}{Abzählbarkeit}[Skrpt Def. 2.8]
Eine Menge $M$ heißt abzählbar, wenn es eine surjektive Funktion $f:\mathbb{N}\to M$ gibt.
\end{definition}
\subsubsection{Kodierung einer TM (Gödelnummern)}
\begin{itemize}
    \item $i$ Nummerierung des Aktuellen Zustands
    \item $a_k$ Nummer des gelesenen Buchstabens
    \item $j$ Nummer des Ziel Zustands
    \item $a_l$ Nummer des zu schreibenden Buchstabens
    \item $0=L,00=R,000=N$ Bewegungsrichtung
\end{itemize}
$\Rightarrow$ für einen Eintrag $z$ in der Transitionstabelle einer TM gilt dann 
$code(z)=0^i10^k10^j10^l(0|00|000)$. Die gesamte Kodierung der TM M gibt sich dann aus folgender Kombination.
$\goedl{M}=111code(z_1)11code(z_2)11\dots11code(z_s)111$
\\ \\
Die Menge der TM Kodierungen ist entscheidbar. Die Menge der Turingmaschienen über $\{0,1\}$ ist abzählbar.\\ \\
Gödelisierung: Kodierung von logischen Behauptung (' x wird durch den Beweis y formal bewiesen')
\\ \\ 
Die Potenzmenge der Natürlichenzahlen $\mathcal{P}(\mathbb{N})$ ist überabzahlbar. Beweis: \begin{itemize}
    \item Annahme $\mathcal{P}(\mathbb{N})$ ist abzählbar $\to \exists f:\mathbb{N}\to\mathcal{P}(\mathbb{N})$
    \item wähle Teilmenge $K=\{i\in\mathbb{N}|i\not\in f(i)\}\subseteq\mathcal{P}(\mathbb{N})$
    \item $\rightarrow \exists i_0:f(i_0)=K$
    \item $\LongRightarrow i_0\in K\Longleftrightarrow i_0\not\in f(i_0)\Longleftrightarrow i_0\not\in K \text{\Lightning}$ 
\end{itemize}\\ \\

$\Longrightarrow$ Die Menge aller Sprachen $L\subseteq\{0,1\}^*$(Potenzmenge) ist nicht abzählbar.\\ \\
Die Menge der entscheidbaren Sprachen $L\subseteq\{0,1\}^*$ ist abzählbar.
\subsection{Halteproblem für Turingmaschinen}
\begin{itemize}
    \item Gegeben: Turingmaschine M über $\{0,1\}$, Eingabewort $w\in\{0,1\}^*$
    \item Stoppt die TM M auf der Eingabe w ?
    \item Formal: $H=\{\goedl{M}w|M\text{ hält auf }w\}$
    \item \underline{Das Halteproblem $H$ ist nicht entscheidbar!}
    \item $H$ ist turing aufzählbar
    \item $\bar{H}$ ist nicht aufzählbar! da sonst $H$ entscheidbar
\end{itemize}

\paragraph{Satz 2.16} Es gibt eine universelle Turingmaschine.
\paragraph{Satz 2.19} Die Klasse der aufzählbaren Sprachen über $\{0,1\}$ ist abgeschlossen unter der Vereinigung und Durschnitt, nicht jedoch unter Komplement.
\paragraph{Sats 2.20} Die Klasse der entscheidbaren Sprachen (über $\{0,1\}$) ist eine Boolsche Algebra - sie ist abgeschlossen über unter Vereinigung, Durschschnitt und Komplement.
\paragraph{$H$}$H$ ist aufzählbar mit maximaler SChwierigkeit.
\paragraph{Sats 2.33} Eine Sprache $L$ ist aufzählbar gdw. $L\leq H$
\paragraph{Klasse RE} KLasse RE ist die Klasse aller aufzählbarer Sprachen\begin{itemize}
    \item Sprache $L_0$ vollständig in RE falls
    \item Sprache $L_0\in RE$ 
    \item $\forall L \in RE:L\leq L_0$
\end{itemize}
\subparagraph{co-RE} Klasse alle nicht aufzählbarer Sprachen (Komplement von RE)
\subparagraph{$H_{total}$} Die Sprache $H_{total}$ ist nicht aufzählbar, genauso wie ihr Komplement $\bar{H}_{total}$, weiter hin gilt: $H_\epsilon\leq H_{total}\land H_\epsilon\leq\bar{H}_{total}$

\subsection{Liste unentscheidbarer Probleme}
\begin{itemize}
    \item allgemeine Halteproblem $H=\{\goedl{M}w|M\text{ hält auf }w\}$
    \item einfaches Halteproblem $H_\epsilon = \{\goedl{M}\epsilon|M\text{ hält auf }\epsilon}$[Satz 2.25]
    \item Äquivalenzproblem $Eq=\{\goedl{M_1}\goedl{M_2}|\forall w\in\{0,1\}^*:\goedl{M_1}w=\goedl{M_2}w\}$ berechnen $M_1$ und $M_2$ die selbe Funktion?[Satz 2.26]
    \item Totalitätsproblem $T=\{\goedl{M}|\forall w\in\{0,1\}:\goedl{M}w\neq\perp\}$ hält $M$ auf allen Eingaben?[Satz 2.27]
\end{itemize}
\subsection{Reduktionsmethode}
Nehmen an ein Problem P kann entschieden werden, dann gibts es eine TM M die dieses Problem lößt. Kann man diese TM M mit einer anderen TM so umformen das sie ein bekanntes unentscheidbares Problem Q lößt? Wenn Ja ist das gegebene Problem P unentscheidbar. gechrieben $Q\leq P \to$ P ist mindestens so schwierig wie Q. P ist reduzierbar auf Q.\\ \\ 
$P\leq Q \Longleftrightarrow \exists f:I_P\to I_Q$ f berechenbar mit $x\in P gdw. f(x)\in Q\forall x\in I_P$
\paragraph{Reduktionslemma [2.24]} Gelte $p\leq Q$. Wenn P unentscheidbar, dann auch Q.
\paragraph{Bem. 2.32} $K\leq L\land L$ aufzählbar $\Rightarrow K$ aufzählbar
\paragraph{Satz 2.37} $L\cubseteq \{0,1\}^*$ ist aufzählbar (in RE)gdw. es gibt entscheidbare Spraceh $L_0\subseteq\{0,1,\#\}^*$, sodass gilt $u\in L\Longleftrightarrow\exists v:U\# v\in L_0$
\paragraph{Satz 2.38} $L\subseteq \{0,1\}^*$ ist Komplement einer aufzählbaren Sprache gdw. es gibt eine entscheidbare Sprache $L_0\subseteq\{0,1,\#\}^*$, sodass gilt $U\in L\Longleftrightarrow\forall v:u\#v\in L_0$
\subsection{Der Satz von Rice}
Eine Eigenschaft E einer TM heißt nicht-trivial wenn es eine TM mit E gibt, aber auch eine TM, die die Eigenschaft E nicht hat. Eine Eigenschaft einer TM M,  E heißt semantisch wenn E für M nur von der durch M bereschneten Funktion abhängt. $M_1,M_2$ berechnen die selbe Funktion, dann gilt $M_1$ hat E gdw. $M_2$ hat E.
\begin{itemize}
    \item TM-Eigenschaft E nicht-trivial, wenn es gibt TM die E hat und TM die die Eigenschaft E nicht hat.
    \item TM-Eigenchaft E semantisch, wenn die Eigenschaft nur von der berechneten Funktion abhängt\begin{itemize}
        \item $M_1\land M_2$ berechnen die selbe Funktion $\Longrightarrow M_1$ hat E gdw. $M_2}$ hat E
    \end{itemize}
\end{itemize}
\paragraph{Satz von Rice} Jede nicht-triviale semantische Eigenschaft E ist unentscheidbar. 
\subparagraph{Formulierung:}
\begin{align*}
    \text{Sei }&\mathcal{R}=\text{ Menge der von TM berechenbaren patiellen Funktionen.}\\
    \text{Sei }&\mathcal{S}\subset\mathcal{R},\emptyset\subsetneq\mathcal{S}\subsetneq\mathcal{R}\\
    &\text{Dabb ist die Sprache}\\
    L(\mathcal{S})&=\{\goedl{M}|M \text{ berechnet eine Funktion aus }\mathcal{S}\}\\
    &\text{ nicht entscheidbar}
\end{align*}
$\rightarrow$ Wenn nach Eigenschaften der eingegebnenen TM gefragt wie, wie "M berechnet bei Eingabe 17 die Zahl 42" dann Satz von RIce anwenden
\subsection{HIlberts 10. Problem + Posts Korrespondenzproblem}
\subsubsection{Definition Hilberts 10. Problem}
Beschreibe einen Algorithmus, der entscheidet, ob es ein gegebenes Polynom mit ganzzahligen Koeffizienten eine ganzzahlige Nullstelle hat.\begin{align*}
    N=&\{p|p\text{ ist ein Polynom mit einer ganzzahliger Nullstelle}\}\\
    &\to \text{ die menge der ganzzahligen Polynome ist aufzählbar}
\end{align*}
$\Longrightarrow$ 10. Hilbertsproblem ist unentscheidbar [Satz von Matijasevic]
\subsubsection{Potsche Korrespondenzproblem Definition (PKP)}
Eine Instanz des PKP besteht aus einer Menge \begin{align*}
    K=\left\{\left[\frac{x_1}{y_1}\right],\dots,\left[\frac{x_k}{y_k}\right]\right\}
\end{align*}wobei $x_i,y_i$ nichtleere Wörter über einem endlichen Alphabet $\Sigma$ sind. Es soll entschieden werden, ob es eine korrespondierende Folge von Indizes $i_1,\dots,i_n\in\{1,\dots,l\}.n\geq 1$ gibt, also eine Folge, sodass gilt $x_{i_1}x_{i_2}\dots x_{i_n}=y_{i_1}y_{i_2}\dots y_{i_n}$\subsubsection{Modifiziertes PKP (MPKP)}
Eine Instanz des PKP besteht aus einer Menge \begin{align*}
    K=\left\{\left[\frac{x_1}{y_1}\right],\dots,\left[\frac{x_k}{y_k}\right]\right\}
\end{align*}wobei $x_i,y_i$ nichtleere Wörter über einem endlichen Alphabet $\Sigma$ sind. Es soll entschieden werden, ob es eine korrespondierende Folge von Indizes $i_1,\dots,i_n\in\{1,\dots,l\}.n\geq 1$ gibt, also eine Folge, sodass gilt $x_1x_{i_2}\dots x_{i_n}=y_1y_{i_2}\dots y_{i_n}$ unterschied: die FOlge soll mit dem ersten Stein anfangen.
\subsubsection{Es gilt:}
\begin{align*}
    MPKP\leq& PKP\\
    H\leq& MPKP\\
    \Longrightarrow H\leq & PKP
\end{align*}
Das PKP ist nicht entscheidbar, aber aufzälbar. Das Komplement von PKP ist nicht aufzählbar.

\subsection{WHILE \& LOOP-Programme}
\begin{definition}{Turing-mächtig}
Eine Programmiersprache wird als Turing-Mächtig bezeihnet, wenn jede berechenbare Funktion auch durch ein Programm in dieser Programmiersprache berechnet werden kann.
\end{definition}
\subsubsection{WHILE-Programme}
\begin{itemize}
    \item Variablen $x_1,x_2,\dots$
    \item Symbole $;,:=,+,\neq$
    \item key-words: if, then, else, endif, while, do endwhile
    \item Eingabe in den ersten n Variablen $x_1,x_2,\dots,x_n$. Die Variablen $x_{n+1},\dots$ werden mit 0 initialisiert
    \item Ergebnis steht am Ende in Variable $x_1$.
    
\end{itemize}
$\to$ WHILE programm sind induktiv definiert
\paragraph{Die} WHILE-Programmiersprache ist turing mächtig.
\subsection{LOOP-Programme \& Ackermannfunktion}
\subsubsection{LOOP-Programme}
\begin{itemize}
    \item definiert wie WHILE , LOOP statt While. LOOP $x_i$ DO P ENDLOOP. Führe P $x_i$ mla durch.
    \item Alle Loop Programme sind durch While Programme simulierbar (Satz 2.47)
    \item Menge Loop berechenbarer Funktionen $\neq$ Menge totaler Funktionen, da Ackerman eine totale Funktion ist die nicht loop berechenbar ist.
\end{itemize}
\subsubsection{Ackermann Funktion}
\begin{align*}
    A(0,n) &=n+1 &\text{ für }n\geq 0\\
    A(m+1,0)&=A(m,1) &\text{ für }m\geq 0\\
    A(m+1,n+1)&=A(m,A(m+1,n)&\text{ für }m,n\geq 0
\end{align*}
\begin{itemize}
    \item ist total und berechenbar
    \item terminiert für alle $(x,y)\in\mathbb{N}^2$
    \item Ergebnis ist immer eine natrüliche Zahl 'Die Ackermann funktion terminiert'
    \item streng monoton wachsend
    \item wächst sehr schnell 
    \item für jedes Loop-Programm P gibt es eine natürliche Zahl $n\in \mathbb{N}$, s.d. für alle $n$ gilt $F_P(n)<A(m,n)$
    \item die Ackermann funktion ist nicht LOOP berechenbar (Satz 2.62)
\end{itemize}
\subsection{Primitivrekursiv \& $\mu$-rekursive Funktionen}
\subsubsection{Formalismus der rekursiven FUnktionen}
\begin{itemize}
    \item Nullfunktion $o^k:\mathbb{N}^k\to\mathbb{N},\forall k\geq 0$\\$o^k(x_1,\dots,x_k)=0,\forall x_1,\dots,x_k\in\mathbb{N}$
    \item Projektion $\forall 1\leq k \leq k\in\mathbb{N}$:\\$p_i^k(x_1,\dots,x_i,\dots,x_k)=x_i,
    \forall x_1,\dots,x_k$
    \item Nachfolger $s:\mathbb{N}\to\mathbb{N}$ mit\\$s(n)=n+1,\forall n\in\mathbb{N}$
    \item Einsetzung, $h$ n stellig und $g_1,\dots,g_n$ jeweils k-stellig, so entsteht f (k-stellig) aus $h,g_1,\dots,g_k$ durch Einsetzung wenn:\\
    $f(x_1,\dots,x_k)=h(g_1(x_1,\dots,x_k),\dots,g_n(x_1,\dots,x_k))$
    \item Primitive Rekursion:\\
    $g\quad k-$stellig und $h\quad(k+2)$ stellig, so entsteht $f((k+1)stellig)$ aus g und h durch prim.rek., wenn\\\begin{align*}
        f(0,x_1,\dots,x_k)&=f(x_1,\dots,x_k)\\
        f(n+1,x_1,\dots,x_k)&=h(f(n,x_1,\dots,x_k),n,x_1,\dots,x_k)
    \end{align*}
    \item Addition: $add:\mathbb{N}^2\to\mathbb{N}:$\\\begin{align*}
        add(0,x)&=x\\
        add(n+1,x)&=s(add(n,x))
    \end{align*}
    \item Multiplikaiton: $mult:\mathbb{N}^2\to\mathbb{N}:$\\\begin{align*}
        mult(0,x)&=0\\
        mult(n+1,x)&=add(mult(n,x),x)
    \end{align*}
    \item Subtraktion $sub:\mathbb{N}^2\to\mathbb{N}:$\\\begin{align*}
        sub(x,0)&=x\\
        sub(x,y+1)&=u(sub(x,y))\\
        u(0)&=0\\
        u(n+1)&=n
    \end{align*}
\end{itemize}
\subsubsection{Satz 2.68} Die Klasse der prim.rek. Funktionen stimmt genau mit der Klasse der LOOP-berechenbaren Funktionen überein.
\subsubsection{Def 2.69} Eie Funktion $f:\mathbb{N}\leadsto\mathbb{N}$ heißt rekursiv/partiell rekursiv/$\mu$-rekrusiv, wenn sie aus Basisfunktionen durch endlichmaliege Anwendung der Prozesse Einsetzung, primitive Rekrusion und Anwendung des $\mu$-Operators entsteht.
\\ \\
Der $\mu$-Operator extrahiert für eine  $(k+1)$-stellige Funktion $g$ zu $x_1,\dots,x_k$ das kleinste $y$ sodass $g(z,x_1,\dots,x_k)$ gilt.
\\ \\
Aus $(k+1)$-stellige Funktion entsteht die $k$-stellige Funktion $f$ durch anwendung des $\mu$-Operators, wenn:\\
$f(x_1,\dots,x_k)=$ kleinste $y$ mit $g(y,x_1,\dots,x_k)=0$, wenn $\forall z<y g(z,x_1,\dots,x_k)\neq 0$ definiert ist, falls ein solches $y$ definiert ist, sonst $\perp$ 
\begin{itemize}
    \item Aus Funk. $g,(k+1)$-stellig wird $f,k$-stellig wenn:\begin{enumerate}
        \item $f(x_1,\dots,x_k)=y$ mit $y$ ist das kleinste $y$ sodass $g(y,x_1,\dots,x_k)=0$
        \item $\forall z<y$ ist $g(z,x_1,\dots,x_k)\neq 0$ definiert.
        \item existiert kein $y$ mit diesen Eigenschaften $\perp$
    \end{enumerate}
    
\end{itemize}
\subsubsection{Satz 2.70} Die KLasse der Rekursiven Funktionen stimmt mit genau mit der Klasse der WHILTE/TURING/RAM berechenbaren Funktionen überein.
\subsection{Zusammenfassung Kapitel 2}
\begin{itemize}
    \item Church/Turing-These: klasse der TMs ist gleich der Intuitiv berechenbaren Funktionen
    \item L ist aufzählbar, wenn sie defintionsbereich einer berechenbaren Funktion ist ($\exists$ TM die diese Funktion berechnet)
    \item Funktion f ist berechenbar wenn ihr Graph aufzählbar.
    \item Sprache L semi-entscheidbar gdw. L aufzählbar
    \item eine Menge M ist abzählbar wenn es eine surjektive Abbildung von $\mathbb{N}$ auf M gibt.\begin{itemize}
        \item Abzählbarkeit $\neq$ Berechenbarkeit!
    \end{itemize}
    \item das allgemeine Halteproblem $H=\{\goedl{M}w|M\text{ hält auf }w\}$ ist nicht entscheidbar\begin{itemize}
        \item $H$ ist Turing-Aufzählbar [Satz 2.17]
        \item $\bar{H}$ ist nicht aufzählbar [Satz 2.18] da H nicht entscheidbar, wäre $\bar{H}$ aufzählbar, dann wäre mit $H$ aufzählbar H entscheidbar \Lightning.
    \end{itemize}
    \item Reduktion: Ein Problem $P$ lässt sich auch ein andere Problem $Q$ reduzieren, wenn es eine berechenbare Funktion $f_P$ gibt sodass $x\in P $gdw. $f_P(x)\in Q$ gilt.\begin{itemize}
        \item $P\leq Q$ P ist reduzierbar auf Q
        \item ist Q unentscheidbar, dann auch P (vorr. $P\leq Q$)
        \item ist Q aufzählbar, dann auch P (vorr. $P\leq Q$)
        \item Sprache L ist aufzählbar, wenn $L\leq H$
    \end{itemize}
    \item Satz von Rice bei Sprachen die auf nach nicht-trivialen semantischen EIgenschaften der Eingegebenen Funktion/TM fragen:\begin{itemize}
        \item nicht-trivial, es gibt TMs die diesse Eigenschaft haben und welche die sie nicht haben
        \item semantisch, die Eigenschaft hängt von der von M berechneten Funktion ab.
        \item Zeige \begin{enumerate}
            \item definiere Menge $\mathcal{S}$
            \itme Zeige $\mathcal{S}\neq\emptyset$ Bsp. $f_M(x)=42,\forall x\in\mathbb{N}$
            \item Zeige $\mathcal{S}\neq\mathcal{R}$ Bsp $f(x)=0,\forall x\in\mathbb{N}\Rightarrow x\not\in\mathcal{S}$
            \item es folgt nach SvR\footnote{Satz von Rice} das $L_{eingabe}=L(S)$ nicht entscheidbar.
        \end{enumerate}
    \end{itemize}
    \item PKP und MPKP sind nicht entscheidbar
    \item WHILE-Programme sind turing mächtig 
    \item LOOP-Programme sind nicht turing möchtig
    \item für alle LOOP Programme gibt es ein m sodass $\forall n:F_P(n)<A(m,n)$
    \item es gibt keine berechenbare Funktion die schneller als die Busybeaver Funktion wächst\\$\to$ busybeaver ist nicht berechenbar
    \item rekursive Funktionen bestehen aus der Nullfunktion, Projektion und Nachfolgerfunktion
    \item $\mu$-Rekursive Funktion entsteht aus Basisfunktionen, endlichmalige Anwendung der Prozesse Einsetztung, primitive Rekursion und Anwednung des $\mu$-Operators
    \item $LOOP\equiv \text{primitiv rekrusiv} \subsetneq TM\equiv RAM\equiv WHILE\equiv \mu\text{-rekursiv}$
\end{itemize}
\section{Komplexität}
\begin{itemize}
    \item wie schwer ist es ein Problem zu lösen?
    \item Welche Probleme lassen sich mit effizienten Algorithmen lösen?
\end{itemize}
\subsection{P}
\begin{itemize}
    \item worstcase Laufzeit eines Algorithmus $A$: $t_A(n),n\in\mathbb{N}$ für eine Eingabe der Länge $n$ im logarithmischen Kostenmaß.
    \item ein Algorithmus ist polynomiell beschränkt, wenn $\exists\alpha\in\mathbb{N}:t_A(n)=O(n^\alpha)$\\$\to$ die Laufzeit ist durch ein polynom beschränkt.
\end{itemize}
\begin{definition}{Komplexitätsklasse P} ist die Klasse der Probleme, für die es einen Polynomialzeitalgorithmus (effiziente Algorithmen) gibt.
\end{definition}
\subsubsection{Liste von Problemen in P}
\begin{itemize}
    \item Sortieren 
    \item Kürzeste Wege
    \item Minnimaler Spannbaum
    \item Graphenzusammenhang
    \item Maximaler Fluss
    \item Maximum Matching
    \item Lineare Prorammierung
    \item GGT
    \item Primzahltest
\end{itemize}
\subsubsection{Problem: Sortieren}
\begin{align*}
    \text{Eingabe }:& N\text{ (binär Kodierte) Zahlen }a_1,\dots,a_N\in\mathbb{N}\\
    \text{Ausgabe }:& \text{ aufsteigend sortierte Folge der Eigabezahlen}
\end{align*}
\subsubsection{Problem: Graphenzusammenhang}
\begin{align*}
    \text{Eingabe:}&\text{ Graph }G=(V,E)\\
    \text{Frage:}&\text{ Ist $G$ Zusammenhängend?}\\
    \to&\text{Eingabe als Adjazenzmatrix}
\end{align*}
Um zu zeigen das ein Problem G in P ist: geben einen Poly.zeit Algorithmus an der G löst.
\subsection{NP}
NP ist die Klasse der Entscheidungsprobleme, die durch eine NTM erkannt werden, deren worst case Laufzeit $t_M(n)$ poly. beschränkt ist.\\ \\ 
Alternativ: Eine Sprache L ist in NP, wenn es für die Eingaben aus L ein Zertifikat polynomieller Länge gibt mit dem sich die Zugehörigkeit zu L in polynomieller Zeit verifizieren lässt.Formal:\\ \\ 
Eine Sprache $L\subseteq\kleene$ ist genau dann in NP, wenn es einen Polynomialzeitalgorithmus V (einen Verifizierer) en ein Polynom p mit der folgenden Eigenschaft gibt:
\begin{equation*}
    x\in L \Leftrightarrow\exists y\in\{0,1\}^*,|y|\leq p(|x|): V \text{ akzeptiert}y\#x
\end{equation*}

\subsubsection{NTM}
\begin{definition}{NTM}
Wie eine TM nur das die Zustandsüberführungsfunktion eine Relation ist.
\begin{align*}
    \delta\subseteq((Q/\{\bar{q}\})\times\Gamma)\times(Q\times\Gamma\times\{L,R,N\}))
\end{align*}
Eine NTM akzeptiert eine Eingabe $x\in\kleene$, falls es mindestens einen Rechenweg gibt, der in eine akzeptierende Endkonfiguration führt. Die von der NTM erkannte Spache L besteht aus allen von der NTM akzeptierten Wörtern.\\ \\
Laufzeit einer NTM auf einer Eingabe ist die Länge des Kürzestens akzeptierten Rechenweges.
Die Worst-case Laufzeit für eine Eingabelänge $n$ ist der längeste mögliche Rechenweg, aller akzeptierten Eingaben der Länge n. wird ein WOrt nicht akzeptiert, ist die Laufzeit 0.
\end{definition}
\subsubsection{Probleme in NP}
\paragraph{Cliquenproblem - CLIQUE:}
\begin{align*}
    \text{Eingabe}:&\text{ Graph }G=(V,E), k\in\{1,\dots,|V|\}\\
    \text{Frage}:&\text{ Gibt es eine $k$-Clique}
\end{align*}
\paragraph{Rucksackproblem, Knapsack Problem - KP}
Beim KP wird eine Teilmenge K von N gegebenen Objekten mit Gewichten $w_1,\dots,w_N$ und Nutzen/Profiten $p_1,\dots,p_N$ gesucht, sodass die Objekte aus K in einen Rucksack mit Gewichtsschranke $b$ passen und dabei der Nutzen maximiert wird.
\begin{align*}
    \text{Eingabe: }&b\in\mathbb{N},w_1,\dots,w_N\in\{1,\dots,b\},p_1,\dots,p_N\in\mathbb{N}\\
    \text{zulässige Lösungen:}&K\subseteq\{1,\dots,N\},so dass \sum_{i\in K}w_i\leq b\\
    \text{Zielfunktion: }& max \sum_{i\in K}p_i
\end{align*}
Entscheidungsvariante: Gibt es eine teilmenge der Objekte mit Nutzen mindestens p ?
\paragraph{Bin Packing Problem - BPP}
Suche Verteilung ovn N objekten mit Gewichten $w_1,\dots,w_N$ auf eine möglichst kleine Anzahl von Behältern mit Kapaziäte b. Anzahl der Behälter = k\begin{align*}
    \text{Eingabe: }&b\in\mathbb{N},w_1,\dots,w_N\in\{1,\dots,b\}\\
    \text{zulässige Lösungen: }&k\in\mathbb{N}\text{ und Funktion }f:\{1,\dots,N\}\to\{1,\dots,k\}\text{ sodass }\\
    &\forall i\in\{1,\dots,k\}:\sum_{f\in f^{-1}(i)}w_j\leq b\\
    \text{Zielfunktion: }& \text{minimiere } k 
\end{align*}
\paragraph{Traveling Saleman Problem - TSP}
Beim TSM is tein vollständiger Graph aus N Knoten mit Kantengewichten gegeben. Gesucht ist eine Rundreise (ein Hamiltonkreis, eine Tour) mit kleinsmöglichen Kosten.
\begin{align*}
    \text{Eingabe: }&c(i,j)\in\mathbb{N} \text{ für }i,j\in\{1,\dots,N\},\text{ wobei gilt }c(i,j)=c(j,i)\\
    \text{zulässige Lösungen: }&\text{ Permutationen $\pi$ auf }\{1,\dots,N\}\\
    \text{Zielfunktion: }&\text{Minimiere }\sum_{i=1}^{N-1}c(\pi(i),\pi(i+1))+c(\pi(N),\pi(1)) 
\end{align*}
\underline{Die Entscheidungsvarianten von KP,BPP und TSP sind in NP.}
\underline{Wenn die Entscheidungsvariante von KP in polyzeit lösbar dann auch die Optimierungsvariante}gilt das für alle?
\paragraph{Knotenfärbung COLORING}
\begin{align*}
    \text{Eingabe: }& \text{Graph }G=(V,E), \text{ Zahl }k\in\{1,\dots,|V|\}\\
    \text{Frage: }& \text{ Gibt es eine Fäbung }c:V\to\{1,\dots,k\} \text{ der Knoten von G mit k Farben,}\\&\text{ sodass benachbarte Knotne verschiedenen Knoten haben? d.h.: }\forall\{u,v\}\in E:c(u)\neq c(v)?\\
    COLORING & \text{ NP - Vollständig}
\end{align*}
\paragraph{ Erfüllbarkeitsproblem SAT}
\begin{align*}
    \text{Eingabe: }&\text{Aussagenlogische Formel}\phi \text{ in KNF}\\
    &(x_1\lor x_2)\land (x_2\lor x_3)\\
    \text{Frage: }&\text{Gibt es eine erfüllende Belegung für }\phi?
\end{align*}
SAT hat Polyzeit algo $\to$ COLORING hat Polyeit algo
COLORING keinen Polyzeit algo $\to$ SAT keinen Polyzeit algo
\paragraph{3SAT}\begin{align*}
    \text{Eingabe: }&\text{ Aussagenlogische Formel$\phi$ in 3SAT}\\
    &\text{ (alle Klauseln enthalten genau 3 Literale)}\\
    \text{Frage: }&\text{ Gibt es eine erfüllende Belegung für $\phi$?}\\
    SAT&\leq_P 3SAT\\
    3SAT & \text{ NP-Vollständig}
\end{align*}\paragraph{Hamiltonkreis}
$\to$ Jeder Knoten wird genau einmal besucht\\
\subparagraph{Hamiltonkreis un/gerichtet HC/DHC:}
\begin{align*}
    \text{Eingabe: }&\text{Graph }G=(V,E)\\
    \text{Frage: }&\text{ Gibt es einen Hamiltonkreis in G?}
\end{align*}
\subparagraph{LEMMA 3.39}$HC\leq_p DHC \land DHC\leq_p HC$
\subparagraph{Satz 3.40}$HC/DHC$ NP-Vollständig
\paragraph{SUBSET-SUM:}
\begin{align*}
    \text{Eingabe: }&a_1,\dots,a_N\in\mathbb{N},b\in\mathbb{N}\\
    \text{Frage: }&\text{ Gibt es }K\subseteq\{1,\dots,N\}\text{ mit }\sum_{i\in K}a_i=b?\\
    SUBSETSUM:& \text{NP-Vollständig}\\
    \to&\text{ spezialfall von SUBSETSUM, deswegen NP-Vollständig}
\end{align*}
\paragraph{PARTITION:}
\begin{align*}
    \text{Eingabe: }&a_1,\dots,a_N\in\mathbb{N}\\
    \text{Frage: }&\text{ Gibt es }K\subseteq\{1,\dots,N\}\text{ mit }\sum_{i\in K}a_i=\sum_{i\in\{\1,\dots,N\}/K}a_i
\end{align*}
\subsection{Satz 3.2} Für jedes Entscheidungsproblem $L\in NP$ gibt es einen Algorithmus A, der L entscheidet, und dessen worst-case Laufzeit durch $2^q(n)$ nach oben beschränkt ist, wobei q ein geeignetes Polynom ist.

\subsubsection{P $\subseteq$ NP}
\subsubsection{Zeige das Problem in NP}
\begin{enumerate}
    \item gebe eine NTM an
    \item Zeige das es ein Zertifikat mit polyzeit Zertifizierer gibt.
\end{enumerate}
\subsection{NP-Vollständigkeit}
\subsubsection{Polynomielle Reduktion}
$L_1,L_2$ seien zwei Sprachen über $\Sigma_1,\Sigma_2$. $L_1$ ist polynomiell Reduziertbar auf $L_2$, wenn es eine Reduktion von $L_1$ nach $L_2$ gibt, die in polynomieller Zeit berechenbar ist. Wir schreiben $L_1\leq_P L_2$.\\ \\
\begin{equation*}
    L_1\leq_P L_2, L_2\in P\Rightarrow L_1\in P
\end{equation*}
$L_1$ wird auf $L_2$ reduziert.
\subsubsection{NP-Hart}
Ein Problem heißt NP-hart(schwer) wenn gilt:
\begin{equation*}
    \forall L'\in NP:L'\leq_P L
\end{equation*}
\begin{align*}
    L \text{ NP-Hart }&\land L\in P\Rightarrow P=NP\\
    L^* \text{ NP-Hart }&,L^*\leq_PL\Rightarrow L \text{ NP-hard}
\end{align*}
\subsubsection{NP-Vollstädig}
$L$ ist NP-Vollständig $\Leftrightarrow$
\begin{enumerate}
    \item $L\in NP \land$
    \item $L$ NP-hard
\end{enumerate}
\paragraph{NPC} beschreibt die Klasse der NP-vollständigen Probleme.
\subsection{Satz von Cool und Levin}
SAT ist NP-Vollständig.
\subsection{Komplexitätslandschaft}
\begin{itemize}
    \item PSPACE: KLasse der Probleme, die mit einem Polynomiell beschränkten Band auf einer TM gelöst werden können\\$NP\subseteq PSPACE$
    \item EXPTIME: Klasse der Probleme mit Laufzeitschranke $2^{p(n)$ mit geeignetem Polynom.\\$NP\subseteq EXPTIME$
    \item CO-NP, Komplement der Klasse NP. Enthält alle Probleme bei denen die "Nein"-Antwort in polyzeit verifiziert werden können.
    \item Annahme: $P\subsetneq NP\subsetneq PSPACE\subsetneq EXPTIME$\\$\to$ Unklar ob Iklusionen echt oder unecht sind.
\end{itemize}
\subsection{Approximations Algorithmen für Np Harte Probleme}
\begin{itemize}
    \item $\alpha$-approximations Algorithmus, $\alpha>1$, für minimierungsprobleme, berechnet eine Lösung mit Zielfunktionswert von höchstens $\alpha\cdot opt(i)$
    \item $\alpha$-approximations Algorithmus, $\alpha<1$, für maximierungsprobleme, berechnet eine Lösung mit Zielfunktionswert von mindestens $\alpha\cdot opt(i)$
    \item $\alpha$ genannt Approximationsfaktor oder Approcimationsgüte
    \item Approximatiins Schema A heißt FPTAS (fully polynomial time approximation scheme), falls Laufzeit von A polynomiell sowohl in n als auch $\frac{1}{e}$ beschränkt ist.\begin{itemize}
        \item typische Laufzeiten:
        \item $O(n^2/\epsilon)\lor O(n^3+\frac{1}{\epsilon^2})$
    \end{itemize}
    \item Approximations Schema A heißt PTAS (polynomial time approximation scheme), falls Laufzeit von A für jedes konstantes $\epsilon>0$ polynomiell in n als beschränkt ist.\begin{itemize}
        \item typische Laufzeiten:
        \item $O(2^{\frac{1}{\epsilon}}n^2)\lor O(n^{\frac{1}{\epsilon}}log(n))$
    \end{itemize}
    \item Für KP gibt es einen Algorithmus, der eine optimale Lösung in $O(N^2P)$ uniformen Rechenschritten berechnet.
    \item KP hat einen FPTAS
\end{itemize}
\subsection{starkt und schwach NP-harte Probleme}
\paragraph{Stark np-hard} Ein NP-hartes Problem, das bei unärer Kodierung einen polynomiellen Algorithmus hat, wird asl schwach NP-hard bezeichnet. Ein Problem, das auch bei unärer Kodierung der EIngabezahlen NP-Hard bleibt, wird als stark NP-hard bezeichnet.
\subparagraph{schwach NP-Hard:}
\begin{itemize}
    \item KP
    \item SUBSETUM
    \item Partition
\end{itemize}
\subparagraph{stark NP-Hard:}
\begin{itemize}
    \item CLIQUE
    \item TSP
    \item BPP
\end{itemize}
Sei $\Pi$ Optimierungsproblem mit ganzahliger, nicht-negativer Zielfunktion. SEi p geeignetes Polynom. Für Eingabe I sei $opt(I)\in\mathbb{N}$ der Wert einer optimalen Lösung, $n_u(I)$ die unäre Eingabelänge. Es gelte $opt(i)<p(n_u(I))$ für jede Eingabe $I$. Falls $\Pi$ stark NP-hart ist, so hat $\Pi$ kein FPTAS, es sein denn es gilt $P=NP$
\subsection{Zusammfassung Kapitel 3}
\begin{itemize}
    \item P ist die KLasse der Probleme, für die es einen Poly.Zeit Algorithmus gibt.
    \item NP ist die KLasse der Sprachen die von einer NTM erkannt werden \begin{itemize}
        \item gebe eine NTM an
        \item gebe ein Zertifikat Polylänge und einen Polyzeit Verifizierer
    \end{itemize}
    \item NPC ist die KLasse der NP-Vollständigen Probleme\begin{itemize}
        \item Clique
        \item BPP (+ E-Var)
        \item KP (+ E-Var)
        \item TSP
        \item COLORING
        \item SAT
        \item 3SAt
        \item HC
        \item DHC
        \item SUBSETSUM
        \item PARTITION
    \end{itemize}
    \item $L$ Np-Vollständig gdw.$L\in NP$ und $L$ NP-Hard
    \item es gilt $L'\leq_P L$ dann \begin{itemize}
        \item $L\in P\Rightarrow L'\in P$
        \item $L\in NP\Rightarrow L'\in NP$
        \item $L$ NP-Vollständig $\Rightarrow L'$ NP-Vollständig
    \end{itemize}
    \item L ist NP-Hard gdw. $\forall L'\in NP: L'\leq_p L$\\ Optimierungsproblem NP-Hard wenn die E-Variante HP-hard ist.
    \item Satz von Cook und Levin: SAT ist NP-VOllständig
    \item stark NP-hard: wenn Problem immer noch NP-SChwer, bei wechsel von binärer Kodierung zu unärer Kodierung
    \item schwach NP-hard: wenn Problem nach wechsel von Binärer zu Unärer Kodiereung danach in P ist.
    \item schwach NP-Hard\begin{itemize}
        \item KP
        \item SUB-SETSUM
        \item PARTITION
    \end{itemize}
    \item startk NP-hard:\begin{itemize}
        \item CLIQUE
        \item TSP
        \item BPP
    \end{itemize}
\end{itemize}
\end{document}