\documentclass[a4paper, 10pt]{article}

%-------------------------- Packete ------------------------------------
\usepackage[german]{babel}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage[top=2cm, left=1.5cm, right=1.5cm, bottom=3cm]{geometry}
\usepackage{mathtools}

\usepackage{ marvosym }
%------------------------- Einstellungen -------------------------------
\setlength{\parindent}{0pt}
\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}
\addtolength{\headheight}{1\baselineskip}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
\newcommand{\bs}{\ensuremath{\backslash}}

\lstset{
inputencoding=utf8,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
%  numbers=left,
%  numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b,
literate={ö}{{\"o}}1 {ä}{{\"a}}1 {ü}{{\"u}}1 {°}{\dg}1 {»}{\frqq}1 {«}{\flqq}1 {ß}{\ss}1 {@}{\@}1 {Ä}{{\"A}}1
}
 
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

%
%Edit the Course, assignment number and members of your group here
%
\newcommand{\courseName}{Berechenbarkeit und Komplexität}

\newcommand{\assignmentNr}{BuK Zusammenfassung WS18/19}


\newcommand{\studentB}{\textbf{Luis Rickert} -- 318153}
\newcommand{\kleene}{\Sigma^*}
\newcommand{\bb}{$b:=b+1$}
\newcommand{\goedl}[1]{\langle {#1}\rangle}
%Left side of the Top header:
\fancyhead[L]{
	\textbf{\courseName}\\
	\assignmentNr{}
}

%Right side of the Top header:
\fancyhead[R]{
	\\	\studentB
}
\pagestyle{fancy}

\begin{document}
\small
\section{Einführung}
\subsection{Modellierung}
\begin{tabular}{l| l}
    $\epsilon$ & das leere Eingabe Wort\\
    \hline
    $\Sigma^0$ & Menge die nur das leere Wort enthält  \\
    \hline
    $\Sigma^k$ & Menge die alle Wörter der Länge k enthält\\
    \hline
    $\kleene$ & 'Kleenesche Abschluss' Menge die alle Wörter über $\Sigma$ enthalten\\
    \hline
    $\epsilon,0,1,00,01,11,000,001,010,011,100,101,\dots$&kanonische Aufzählung
\end{tabular}
\begin{itemize}
    \item Graphen über $\{0,1\}$ kodieren als Adjazenzmatrix
\end{itemize}
\subsection{Algorithmen}
\begin{itemize}
    \item verarbeiten Wörter schrittweise
    \item eindeutig festgelegt durch endlichen text
    \item zu jedem Algo. A mit Eingabe $w$ und Ausgabe $v$ wird eine funktion $f_A$ zugeordent mit $f_A(w)=v$
    \item terminiert $A$ nicht auf einder Eingabe, dann gilt für $f_A=$undefiniert sowie $f_A(w)=\perp$
\end{itemize}
\begin{definition}{Von Algorithmus berechnete Funktion }[Skript 1.6]\begin{itemize}
    \item Algorithms A, Eingabe $w$, Ausgabe $v$ wird funktion $f_A$ zugeordnet mit
    \item $f_A(w)=v$
    \item terminiert $A$ nicht auf $w$: \begin{itemize}
        \item $f_A(w)=$ undefiniert $\lor$
        \item $f_A(w)=\perp$
    \end{itemize}
\end{itemize}
\end{definition}
\begin{definition}{Berechenbare Funktionen }[Skript 1.7]
    \begin{itemize}
        \item Funktion $f$ mit Argumenten aus $M$\\
        $Def(f)=\{m\in M|f(m)\text{ ist definiert}\} \lor$\\
        $Def(f)=\{w\in\kleene|f(w)\neq\perp\}$\\
        'Definitionsbereich von $f$'\\
        $\rightarrow f$ bekommt seine Eingaben aus M, muss aber nicht auf allen definiert sein.
        \item $Bild(f)=\{n\in N|\exists m\in M:f(m)=n\}$\\
        'Bildbereich von $f$'
        \item $f:M\leadsto N$
    \end{itemize}
\end{definition}
\begin{definition}{Totale Funktion }[Skript 1.8]
\begin{itemize}
    \item Wie partielle Funktion nur das das gilt:
    \item $Def(f)=M,f:M\to N$
\end{itemize}
\end{definition}
\begin{definition}{Berechenbare Funktion }[Skript 1.10]\\
Eine Funktion $f:\kleene\leadsto\kleene$ heißt berechenbar gdw. es gibt einen Algorithmus $A$ der $f$ berechnet.
\end{definition}
\begin{definition}{Entscheibar }[Skript 1.12]\\
Sprache $L\subseteq \kleene$ heißt entscheidbar, wenn es einen Algorithmus gibt, der 'Ja' ausgibt wenn das Eingabewort $w$ L enthalten ist und 'Nein' wenn es nicht enthalten ist.
\end{definition}
\begin{definition}{Aufzählungsalgorithmen }[Skipt 1.13]\\
Aufzählungsalogrithmus $A$ startet auf $\epsilon$ und braucht nicht zu terminieren. Er gibt in irgenteiner Reihenfolge Wörter aus. Diese fasst man in der Menge $L_A$ zuammen.\\
Einge Menge von Wörtern oder Sprache L heißt aufzählbar wenn es  einen Aufzähler $A$ gibt mit $L=L_A$.\\ \\
 
$\Rightarrow$ \underline{aufzählbarkeit $\neq$ entscheidbarkeit ! }

\end{definition}\newpage
\subsection{Turingmaschinen}
$\rightarrow$ abstraktes Automatenmodell, entwickelt von Alan Turing, um die Durchführung beliebiger Algorithmen zur Symbolmanipulation präzise zu fassen.
\begin{definition}{Turingmaschine (TM)}[Skript 1.3.1]\\
\begin{itemize}
\item $Q $  endliche Zustandsmenge
\item $\Sigma\supseteq\{0,1\}$ endliche Eingabealphabe
\item $\Gamma\supset\Sigma$,  endliche Bandalphabet
\item $B\in\Gamma/\Sigma$, Leerzeichen (Blank)
\item $q_0\in Q$, Anfangszustand
\item $\bar{q}\in Q$, Stopp/Endzustand 
\item Zustandsübergangsfunktion:\begin{align*}
	\delta:(Q/\{\bar{q}\}\times\Gamma\to Q\times\Gamma\times\{R,L,N\}
\end{align*}
\item Alternative: Darstellung der übergangsfunktion in einer Tabelle, Spalten sind die Symbole des Eingabealphabet, die Zeilen die die möglichen Zustände. Der Endzustand kommt nur als Transitionsziel in den Zellen der Tabelle vor. In den Zellen stehen Tupel der Form $(Zustand,schreiben,richtung)$. D.h. wenn man im Zustand $q_i$ die Eingabe $e$ ließt führt man $(q_j,k,r)$ aus mit $k\in\Gamma\land r\in\{R,L,N\}$ .man wechselt in Zustand $q_j,$ überschreibt die gelesene Zelle mit $k$ und bewegt sich in die Richtug $r$.
\end{enumerate}
\paragraph{k-Spur TM} Eine TM mit k-Spuren, die Spuren stehen unter eineander mit einem Kopf, jedoch können sich die Köpfe nich getrennt von eineander bewegen. Hier wird das Bandalphabet um $k-$dimensionale Vektoren erweitern.
\paragraph{k-Band TM } Eine Tm mit k-Bändern, ähnlich wie k-Spur TM nur das sich die Köpfe unabhäning von einander bewegen können. Die übergangsfuntkion $\delta$ wird zu $\delta:(Q/\{\bar{q}\}\times\Gamma^k\to Q\times\Gamma^k\times\{L,R,N\}^k)$ erweitert. Band 1 ist das Eingabe/Ausgabe Band.\\
Eine TM $M$ mit Rechenzeit $t(n)$ und Platzbedarf $s(n)$ auskommt, kann von einer (1-Band) TM $M'$ mit Zeitbedarf $O(t^2(n))$ und Platzbedarf $O(s(n))$ simuliert werden.
\end{definition}

\subsubsection{Konfiguration}

\paragraph{Konfiguration}
\begin{itemize}
\item Ist ein String $\alpha q\beta$ ,wobei $q\in Q \land \alpha,\beta \in\Gamma^*\to$ man ist im Zustand $q$ und auf dem Band steht $\alpha\beta$ eingerahmt von Blanks.
\end{itemize}
\paragraph{direkte Nachfolgekonfiguration}
\begin{itemize}
\item $\alpha'q\beta'$ heißt \underline{direkte} Nachfolgekonfig. wenn aus $\alpha q\beta$ in  einem Rechenschritt $\alpha'q\beta'$ wird. $\to\alpha q'\beta \vdash \alpha'q\beta'$
\end{itemize}
\paragraph{Nachfolgekonfiguration}
\begin{itemize}
\item $\alpha'' q''\beta''$ heißt Nachfolgekonfiguration von $\alpha q\beta$ wenn $\alpha'' q''\beta''$ in endlich vielen Rechenschritten erreicht werden kann $\to\alpha q\beta \vdash \alpha''q''\beta''$
\end{itemize}
\paragraph{Nachvollziehen einer Berechnung}
Um eine Rechnung nachzuvollziehen gibt man eine Abfolge von Konfigurationen an. z.B.:\begin{align*}
q_00110\vdash 0q_0110\vdash 01q_1 10\vdash 011q_1 0\vdash 0110q_0 B \vdash 0110\bar{q}1 
\end{align*}
\paragraph{TM-Berechenbare Funktionen}
- TM die für jede Eingabe terminiert berechnet eine totale Funktion.
- Das die Ausgabe beginnt unter dem Lese/Schreibkopf und wird nach  rechts durch den ersten Buchstaben begrenzt der nicht im Bandalphabet ist.
Da die meisten TM nicht immer terminieren, berechnen im allegmeinen eine Funktion $F:M\leadsto N$.
\paragraph{TM-Berechenbarkeit, Rekursivität}
Eine funktion heißt TM-berechenbar oder rekursiv, wenn es eine TM gibt, die auf jeder Eingabe $w$ terminiert mit der Ausgabe $f(w)$ .
\paragraph{partiel rekursiv} Eine Funktion $f$ heißt paritell rekursiv, wenn es eine TM M gibt die, genau auf den Wörtern $w\in Def(w)$ terminiert mit der Ausgabe $f(w)$.
\begin{definition}{TM-Entscheibarkeit}[Skript 1.17]\\
Eine Sprache $L$ heißt TM-Entscheidbar oder rekursiv, wenn es eine TM $M$ gibt, die auf allen eingaben $w\in\kleene$ stoppt und die Eingabe $w$ genau dann akzeptiert, wenn $w\in L$ und die Eingabe verwirft wenn $w\not\in L$.
\end{definition}
\begin{definition}{Aufzählungs-Turingmaschine}[Skript 1.18]
\begin{itemize}
\item TM der Form $(Q,\Sigma,\Gamma,B,q_0,bar{q},q_{out},\delta)$
\item $q_{out}$ deints als Ausgabezustand für die einzelnen Wörter, das an Kopfposition beginnt und vor dem ersten Symbol aus $\Gamma /\Sigma$ endet.
\end{itemize}
Eine Sprache $L$ heißt rekursiv aufzählbar, wenn es eine Aufzähler gibt, der die Spache $L$ enthält
\end{definition}
\subsection{Registermaschine}
\begin{definition}{Registermaschine}[Skript 1.3.3]
RAM (Random Access Machine)\begin{itemize}
    \item hat unbeschränkte Anzahl an Registern $c(0),c(1),c(2),\dots,c(n)$
    \item Register $c(0)$ heißt Akkumulator, Rechnerbefehle nutzen dieses Register als implizites Argument, sowie als Speicherort für das Ergebnis von Rechenoperationen
    \item Inhalt der Register sind ganze Zahlen, beliebiger Größe
    \item der Befehlszähler $b$ wird mit $1$ initialisiert
    \item Ram durchläuft ein Programm das aus nummerierten Zeilen besteht, bei der Jede Zeile ein Befehl ist. $b+=1$ wenn der Befehl aus geführt wurde.
    \item ein Programm terminiert sobald der Befehl 'END' erreicht wird
    \item für die Laufzeitberechnung gibt es zwei Modelle:\begin{itemize}
        \item Uniformes Kostenmaß: Jeder Schritt ist eine Zeiteinheit
        \item Logarithmisches Kostenmaß: Laufzeikosten eines Schritts sind poportional zur binären Länge der Zahlen in den angesprochenen Registern 
        \item terminiert die Berechnung nicht, ist die Laufzeit unbeschränkt
    \end{itemize}
\end{itemize} 
\end{definition}
\begin{definition}{"minimales"-RAM-Modell:}[Skript 1.22]
URM-Programm hat die Form $1.instr_1,2.instr_2,\dots,k-1.instr_{k-1},k.end$ wobei jedes $instr_j,\quad j=1,\dots,k-1$ eines der folgenden 3 Typen sein kann.\begin{align}
    INC(X_i)=&\quad &(X_i:=X_i+1)\\
    DEC(X_i)=&\quad &(X_i:=X_i-1)\\
    IF X_i=& 0\quad GOTO &l(1\leq l\leq k)
\end{align}

\end{definition}
\subsubsection{Verlgeich TM vs. RAM}
Jede RAM deren Laufzeit durch $t(n)$ beschränkt ist, kann druch eine TM simuliert werden, die durch ein Polynom $O(q(n+t(n))$ beschränkt ist simuliert werden.[Skript Sat 1.23]\\ \\
Jede $t(n)$ Zeit beschränkte TM  kann durch eine RAM simuliert werden die uniform $O(t(n)+n)$ und logarithmisch \\$O((t(n)+n)log(t(n)+n))$ zeitbeschränkt ist.[Skropt Satz 1.26]

\subsubsection{RAM-Befehle}
\begin{tabular}{|l|l|c|}
    \hline
    Syntax & Zustandsänderung&Änderung von $b$  \\
    \hline
    LOAD $i$ &$c(0)=c(i)$ &\bb \\
    CLOAD $i$ & $c(0)=i$& \bb \\
    INDLOAD $i$&$c(0)=c(c(i))$&\bb\\
    \hline
    STORE $i$ &$c(i):=c(0)$&\bb\\
    INDSTORE $i$ & $c(c(i))=c(0)$&\bb\\
    \hline
    ADD $i$ & $c(0)=c(0)+c(i)$&\bb\\
    CADD $i$ & $c(0)=c(0)+i$&\bb\\
    INDADD $i$ & $c(0)=c(0)+c(c(i))$&\bb\\
    \hline
    SUB $i$ & $c(0)=c(0)\dot{-} c(i)$&\bb\\
    CSUB $i$ & $c(0)=c(0)\dot- i$&\bb\\
    INDSUB $i$ & $c(0)=c(0)\dot- c(c(i))$&\bb\\
    \hline
    MULT $i$ &$c(0)=c(0)\cdot c(i) $ & \bb\\
    CMULT $i$ & $c(0)=c(0)\cdot i$&\bb\\
    INDMLT $i$&$c(0)=c(0)\cdot c(c(i))$&\bb\\
    \hline
    DIV $i$ & $c(0)=\lfloor c(0)/c(i)\rlfoor$&\bb\\
    CDIV $i$ & $c(0)=\lfloor c(0)/i \rfloor$&\bb\\
    INDDIV $i$ &$c(0)=\lfloor c(0)/c(c(i))\rfloor$&\bb\\
    \hline
    GOTO $i$ &-&$b:=i$\\
    IF $c(0)=x$ GOTO $j$&-&$b:=\begin{cases}{j,\text{ falls }c(0)=x\\b+1 \text{ sonst}\end{cases}$\\
    IF $c(0)<x$ GOTO $j$&-&$b:=\begin{cases}j\text{ falls }c(0)<x\\b+1\text{ sonst}\end{cases}$\\
    IF $c(0)\leq x$ GOTO $j$&-&$b:=\begin{cases}j\text{ falls }c(0)\leq x\\b+1\text{ sonst}}\end{cases}$\\
    \hline
    END & ENDE der Rechnung& \\
    \hline
\end{tabular}\footnote{$n/0=0$ für Berechnungen in RAMs}\footnote{$c(0)\dot{-}c(i)=0\Longleftrightarrow c(0)\leq c(i)$}


\subsection{Zusammenfassung Kaptiel 1}
\begin{itemize}
\item eine Funktion ist berechenbar wenn es eine TM gibt, die sie berechnet
\item eine Funktion ist total, wenn sie für alle Möglichen Eingaben definiert ist $f:M\to N$
\item eine Funktion ist partiell, wenn sie für eine Teilmenge der möglichen Eingaben definiert ist $f:M\leadsto N$
\item eine Sprache ist rekursiv/berechenbar, wenn es eine TM gibt die sie entscheidet\begin{itemize}
\item $1\forall w \in L$
\item $0\forall w\not\in L$
\end{itemize}
\item eine Sprache ist paritell rekursiv, wenn es eine TM gibt die auf alle ihren Wörtern hält und diese akzeptiert\begin{itemize}
\item $f_M(w)=v\forall w\in L$
\item $f_M(w)=\perp\forall w\not\in L$ ($\perp\widehat{=}$terminiert nicht bzw nicht definiert)
\end{itemize}
\item eine Sprache ist aufzählbar(=rekursiv aufzählbar), wenn es einen Aufzähler für sie gibt
\item Register der RAM können beliebig große Ganze zahlen enthalten
\item \begin{itemize}
    \item uniformes Kostenmaß: jeder Schritt eine Zeiteinheit
    \item log Kostenmaß: Laufzeitkosten prop. zur bin. Länge der angesprochenen Register
\end{itemize}
\item jede RAM,$t(n)$ beschränkt, kann durch TM simluiert werden Laufzeit : $O(q(n+t(n))$ beschränkt,$p(k)$ polynom
\item jede TM,$t(n)$ beschränkt, kann druch eine RAM simuliert werden, 
\begin{itemize}
    \item uniform: $O(t(n)+n)$ 
    \item log: $O(t(n)+n)log(t(n)+n)$
\end{itemize}

\end{itemize}
\newpage
\section{Berechenbarkeit}
\subsection{Church-Turing-These} Die Klasse der Turing-berechenbaren Funktion stimmt mit der KLasse der intuitiv berechenbaren Funktionen überein.
\subsection{Berechenbarkeit, Aufzählbarkeit, Entscheidbarkeit}

Eine Menge $L\subseteq \kleene$ ist aufzählbar gdw. $Def(f)=L,\quad f:\kleene\leadsto\kleene$. "$L$ ist Definitionsbereich einer berechenbaren Funktion (es gibt eine TM die sie berechnet)"
\paragraph{Graph einer Funktion}
Funktion $f:\kleene\leadsto\kleene ,G_f=\{u\# v|u\in Def(f)\land f(u)=v\}\quad f$ ist genau dann berechenbar, wenn $G_f$ aufzählbar.
\paragraph{Satz 2.5} 
\subparagraph{a)}\boxed{ \text{Ist } $L\subseteq \kleene$ entscheidbar $\Rightarrow\quad L$ aufzählbar}
\subparagraph{b)} \boxed{$L\subseteq\kleene$ entscheibar gdw. $L$ aufzählbar  \underline{und} $\kleene/L$ aufzählbar}

\begin{definition}{semi-entscheibar}[Skript 2.6]
Eine Spreache $L\subseteq\kleene$ heißt semi-entscheidbar, wenn es eine TM $M$ über $\Sigma$ gibt, die:
\begin{align*}
    &\begin{rcases}\forall w&\in L \text{ terminiert } M \\ \forall w&\not\in L, M=\perp\end{rcases} = Aufzähbarkeit\\
    &\Rightarrow \boxed{L\in\kleene \text{ semi-entscheidbar }\Longleftrightarrow L \text{ aufzählbar}[\text{Skript Satz }2.7]}
\end{align*}

\end{definition}
\subsection{Halteproblem H}
Ein Problem ist nicht entcheidbar, dann gibt es keine Möglichkeit diese Problem zu berechnen!
\begin{definition}{Abzählbarkeit}[Skrpt Def. 2.8]
Eine Menge $M$ heißt abzählbar, wenn es eine surjektive Funktion $f:\mathbb{N}\to M$ gibt.
\end{definition}
\subsubsection{Kodierung einer TM (Gödelnummern)}
\begin{itemize}
    \item $i$ Nummerierung des Aktuellen Zustands
    \item $a_k$ Nummer des gelesenen Buchstabens
    \item $j$ Nummer des Ziel Zustands
    \item $a_l$ Nummer des zu schreibenden Buchstabens
    \item $0=L,00=R,000=N$ Bewegungsrichtung
\end{itemize}
$\Rightarrow$ für einen Eintrag $z$ in der Transitionstabelle einer TM gilt dann 
$code(z)=0^i10^k10^j10^l(0|00|000)$. Die gesamte Kodierung der TM M gibt sich dann aus folgender Kombination.
$\goedl{M}=111code(z_1)11code(z_2)11\dots11code(z_s)111$
\\ \\
Die Menge der TM Kodierungen ist entscheidbar. Die Menge der Turingmaschienen über $\{0,1\}$ ist abzählbar.\\ \\
Gödelisierung: Kodierung von logischen Behauptung (' x wird durch den Beweis y formal bewiesen')
\\ \\ 
Die Potenzmenge der Natürlichenzahlen $\mathcal{P}(\mathbb{N})$ ist überabzahlbar. Beweis: \begin{itemize}
    \item Annahme $\mathcal{P}(\mathbb{N})$ ist abzählbar $\to \exists f:\mathbb{N}\to\mathcal{P}(\mathbb{N})$
    \item wähle Teilmenge $K=\{i\in\mathbb{N}|i\not\in f(i)\}\subseteq\mathcal{P}(\mathbb{N})$
    \item $\rightarrow \exists i_0:f(i_0)=K$
    \item $\LongRightarrow i_0\in K\Longleftrightarrow i_0\not\in f(i_0)\Longleftrightarrow i_0\not\in K \text{\Lightning}$ 
\end{itemize}\\ \\

$\Longrightarrow$ Die Menge aller Sprachen $L\subseteq\{0,1\}^*$(Potenzmenge) ist nicht abzählbar.\\ \\
Die Menge der entscheidbaren Sprachen $L\subseteq\{0,1\}^*$ ist abzählbar.
\subsection{Halteproblem für Turingmaschinen}
\begin{itemize}
    \item Gegeben: Turingmaschine M über $\{0,1\}$, Eingabewort $w\in\{0,1\}^*$
    \item Stoppt die TM M auf der Eingabe w ?
    \item Formal: $H=\{\goedl{M}w|M\text{ hält auf }w\}$
    \item \underline{Das Halteproblem $H$ ist nicht entscheidbar!}
    \item $H$ ist turing aufzählbar
    \item $\bar{H}$ ist nicht aufzählbar! da sonst $H$ entscheidbar
\end{itemize}

\paragraph{Satz 2.16} Es gibt eine universelle Turingmaschine.
\paragraph{Satz 2.19} Die Klasse der aufzählbaren Sprachen über $\{0,1\}$ ist abgeschlossen unter der Vereinigung und Durschnitt, nicht jedoch unter Komplement.
\paragraph{Sats 2.20} Die Klasse der entscheidbaren Sprachen (über $\{0,1\}$) ist eine Boolsche Algebra - sie ist abgeschlossen über unter Vereinigung, Durschschnitt und Komplement.
\subsection{Liste unentscheidbarer Probleme}
\begin{itemize}
    \item allgemeine Halteproblem $H=\{\goedl{M}w|M\text{ hält auf }w\}$
    \item einfaches Halteproblem $H_\epsilon = \{\goedl{M}\epsilon|M\text{ hält auf }\epsilon}$[Satz 2.25]
    \item Äquivalenzproblem $Eq=\{\goedl{M_1}\goedl{M_2}|\forall w\in\{0,1\}^*:\goedl{M_1}w=\goedl{M_2}w\}$ berechnen $M_1$ und $M_2$ die selbe Funktion?[Satz 2.26]
    \item Totalitätsproblem $T=\{\goedl{M}|\forall w\in\{0,1\}:\goedl{M}w\neq\perp\}$ hält $M$ auf allen Eingaben?[Satz 2.27]
\end{itemize}
\subsection{Reduktionsmethode}
Nehmen an ein Problem P kann entschieden werden, dann gibts es eine TM M die dieses Problem lößt. Kann man diese TM M mit einer anderen TM so umformen das sie ein bekanntes unentscheidbares Problem Q lößt? Wenn Ja ist das gegebene Problem P unentscheidbar. gechrieben $Q\leq P \to$ P ist mindestens so schwierig wie Q. P ist reduzierbar auf Q.\\ \\ 
$P\leq Q \Longleftrightarrow \exists f:I_P\to I_Q$ f berechenbar mit $x\in P gdw. f(x)\in Q\forall x\in I_P$
\paragraph{Reduktionslemma [2.24]} Gelte $p\leq Q$. Wenn P unentscheidbar, dann auch Q.
\subsection{Der Satz von Rice}
Eine Eigenschaft E einer TM heißt nicht-trivial wenn es eine TM mit E gibt, aber auch eine TM, die die Eigenschaft E nicht hat. Eine Eigenschaft einer TM M,  E heißt semantisch wenn E für M nur von der durch M bereschneten Funktion abhängt. $M_1,M_2$ berechnen die selbe Funktion, dann gilt $M_1$ hat E gdw. $M_2$ hat E.
\begin{itemize}
    \item TM-Eigenschaft E nicht-trivial, wenn es gibt TM die E hat und TM die die Eigenschaft E nicht hat.
    \item TM-Eigenchaft E semantisch, wenn die Eigenschaft nur von der berechneten Funktion abhängt\begin{itemize}
        \item $M_1\land M_2$ berechnen die selbe Funktion $\Longrightarrow M_1$ hat E gdw. $M_2}$ hat E
    \end{itemize}
\end{itemize}
\paragraph{Satz von Rice} Jede nicht-triviale semantische Eigenschaft E ist unentscheidbar. 
\subparagraph{Formulierung:}
\begin{align*}
    \text{Sei }&\mathcal{R}=\text{ Menge der von TM berechenbaren patiellen Funktionen.}\\
    \text{Sei }&\mathcal{S}\subset\mathcal{R},\emptyset\subsetneq\mathcal{S}\subsetneq\mathcal{R}\\
    &\text{Dabb ist die Sprache}\\
    L(\mathcal{S})&=\{\goedl{M}|M \text{ berechnet eine Funktion aus }\mathcal{S}\}\\
    &\text{ nicht entscheidbar}
\end{align*}
$\rightarrow$ Wenn nach Eigenschaften der eingegebnenen TM gefragt wie, wie "M berechnet bei Eingabe 17 die Zahl 42" dann Satz von RIce anwenden
\subsection{Zusammenfassung Kapitel 2}
\begin{itemize}
    \item Church/Turing-These: klasse der TMs ist gleich der Intuitiv berechenbaren Funktionen
    \item L ist aufzählbar, wenn sie defintionsbereich einer berechenbaren Funktion ist ($\exists$ TM die diese Funktion berechnet)
    \item Funktion f ist berechenbar wenn ihr Graph aufzählbar.
    \item Sprache L semi-entscheidbar gdw. L aufzählbar
    \item eine Menge M ist abzählbar wenn es eine surjektive Abbildung von $\mathbb{N}$ auf M gibt.\begin{itemize}
        \item Abzählbarkeit $\neq$ Berechenbarkeit!
    \end{itemize}
    \item das allgemeine Halteproblem $H=\{\goedl{M}w|M\text{ hält auf }w\}$ ist nicht entscheidbar\begin{itemize}
        \item $H$ ist Turing-Aufzählbar [Satz 2.17]
        \item $\bar{H}$ ist nicht aufzählbar [Satz 2.18] da H nicht entscheidbar, wäre $\bar{H}$ aufzählbar, dann wäre mit $H$ aufzählbar H entscheidbar \Lightning.
    \end{itemize}
    \item Satz von Rice bei Sprachen die auf nach nicht-trivialen semantischen EIgenschaften der Eingegebenen Funktion/TM fragen:\begin{itemize}
        \item nicht-trivial, es gibt TMs die diesse Eigenschaft haben und welche die sie nicht haben
        \item semantisch, die Eigenschaft hängt von der von M berechneten Funktion ab.
        \item Zeige \begin{enumerate}
            \item definiere Menge $\mathcal{S}$
            \itme Zeige $\mathcal{S}\neq\emptyset$ Bsp. $f_M(x)=42,\forall x\in\mathbb{N}$
            \item Zeige $\mathcal{S}\neq\mathcal{R}$ Bsp $f(x)=0,\forall x\in\mathbb{N}\Rightarrow x\not\in\mathcal{S}$
            \item es folgt nach SvR\footnote{Satz von Rice} das $L_{eingabe}=L(S)$ nicht entscheidbar.
        \end{enumerate}
    \end{itemize}
\end{itemize}
\end{document}