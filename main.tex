\documentclass[a4paper, 10pt]{article}

%-------------------------- Packete ------------------------------------
\usepackage[german]{babel}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage[top=2cm, left=1.5cm, right=1.5cm, bottom=3cm]{geometry}
%------------------------- Einstellungen -------------------------------
\setlength{\parindent}{0pt}
\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}
\addtolength{\headheight}{1\baselineskip}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
\newcommand{\bs}{\ensuremath{\backslash}}

\lstset{
inputencoding=utf8,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
%  numbers=left,
%  numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b,
literate={ö}{{\"o}}1 {ä}{{\"a}}1 {ü}{{\"u}}1 {°}{\dg}1 {»}{\frqq}1 {«}{\flqq}1 {ß}{\ss}1 {@}{\@}1 {Ä}{{\"A}}1
}
 
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

%
%Edit the Course, assignment number and members of your group here
%
\newcommand{\courseName}{Berechenbarkeit und Komplexität}

\newcommand{\assignmentNr}{BuK Zusammenfassung WS18/19}


\newcommand{\studentB}{\textbf{Luis Rickert} -- 318153}
\newcommand{\kleene}{\Sigma^*}

%Left side of the Top header:
\fancyhead[L]{
	\textbf{\courseName}\\
	\assignmentNr{}
}

%Right side of the Top header:
\fancyhead[R]{
	\\	\studentB
}
\pagestyle{fancy}

\begin{document}
\small
\section{Einführung}
\subsection{Modellierung}
\begin{tabular}{l| l}
    $\epsilon$ & das leere Eingabe Wort\\
    \hline
    $\Sigma^0$ & Menge die nur das leere Wort enthält  \\
    \hline
    $\Sigma^k$ & Menge die alle Wörter der Länge k enthält\\
    \hline
    $\kleene$ & 'Kleenesche Abschluss' Menge die alle Wörter über $\Sigma$ enthalten\\
    \hline
    $\epsilon,0,1,00,01,11,000,001,010,011,100,101,\dots$&kanonische Aufzählung
\end{tabular}
\begin{itemize}
    \item Graphen über $\{0,1\}$ kodieren als Adjazenzmatrix
\end{itemize}
\subsection{Algorithmen}
\begin{itemize}
    \item verarbeiten Wörter schrittweise
    \item eindeutig festgelegt durch endlichen text
    \item zu jedem Algo. A mit Eingabe $w$ und Ausgabe $v$ wird eine funktion $f_A$ zugeordent mit $f_A(w)=v$
    \item terminiert $A$ nicht auf einder Eingabe, dann gilt für $f_A=$undefiniert sowie $f_A(w)=\perp$
\end{itemize}
\begin{definition}{Von Algorithmus berechnete Funktion }[Skript 1.6]\begin{itemize}
    \item Algorithms A, Eingabe $w$, Ausgabe $v$ wird funktion $f_A$ zugeordnet mit
    \item $f_A(w)=v$
    \item terminiert $A$ nicht auf $w$: \begin{itemize}
        \item $f_A(w)=$ undefiniert $\lor$
        \item $f_A(w)=\perp$
    \end{itemize}
\end{itemize}
\end{definition}
\begin{definition}{Berechenbare Funktionen }[Skript 1.7]
    \begin{itemize}
        \item Funktion $f$ mit Argumenten aus $M$\\
        $Def(f)=\{m\in M|f(m)\text{ ist definiert}\} \lor$\\
        $Def(f)=\{w\in\kleene|f(w)\neq\perp\}$\\
        'Definitionsbereich von $f$'\\
        $\rightarrow f$ bekommt seine Eingaben aus M, muss aber nicht auf allen definiert sein.
        \item $Bild(f)=\{n\in N|\exists m\in M:f(m)=n\}$\\
        'Bildbereich von $f$'
        \item $f:M\leadsto N$
    \end{itemize}
\end{definition}
\begin{definition}{Totale Funktion }[Skript 1.8]
\begin{itemize}
    \item Wie partielle Funktion nur das das gilt:
    \item $Def(f)=M,f:M\to N$
\end{itemize}
\end{definition}
\begin{definition}{Berechenbare Funktion }[Skript 1.10]\\
Eine Funktion $f:\kleene\leadsto\kleene$ heißt berechenbar gdw. es gibt einen Algorithmus $A$ der $f$ berechnet.
\end{definition}
\begin{definition}{Entscheibar }[Skript 1.12]\\
Sprache $L\subseteq \kleene$ heißt entscheidbar, wenn es einen Algorithmus gibt, der 'Ja' ausgibt wenn das Eingabewort $w$ L enthalten ist und 'Nein' wenn es nicht enthalten ist.
\end{definition}
\begin{definition}{Aufzählungsalgorithmen }[Skipt 1.13]\\
Aufzählungsalogrithmus $A$ startet auf $\epsilon$ und braucht nicht zu terminieren. Er gibt in irgenteiner Reihenfolge Wörter aus. Diese fasst man in der Menge $L_A$ zuammen.\\
Einge Menge von Wörtern oder Sprache L heißt aufzählbar wenn es  einen Aufzähler $A$ gibt mit $L=L_A$.\\ \\
 
$\Rightarrow$ \underline{aufzählbarkeit $\neq$ entscheidbarkeit ! }

\end{definition}\newpage
\subsection{Turingmaschinen}
$\rightarrow$ abstraktes Automatenmodell, entwickelt von Alan Turing, um die Durchführung beliebiger Algorithmen zur Symbolmanipulation präzise zu fassen.
\begin{definition}{Turingmaschine (TM)}[Skript 1.3.1]\\
\begin{itemize}
\item $Q $  endliche Zustandsmenge
\item $\Sigma\supseteq\{0,1\}$ endliche Eingabealphabe
\item $\Gamma\supset\Sigma$,  endliche Bandalphabet
\item $B\in\Gamma/\Sigma$, Leerzeichen (Blank)
\item $q_0\in Q$, Anfangszustand
\item $\bar{q}\in Q$, Stopp/Endzustand 
\item Zustandsübergangsfunktion:\begin{align*}
	\delta:(Q/\{\bar{q}\}\times\Gamma\to Q\times\Gamma\times\{R,L,N\}
\end{align*}
\item Alternative: Darstellung der übergangsfunktion in einer Tabelle, Spalten sind die Symbole des Eingabealphabet, die Zeilen die die möglichen Zustände. Der Endzustand kommt nur als Transitionsziel in den Zellen der Tabelle vor. In den Zellen stehen Tupel der Form $(Zustand,schreiben,richtung)$. D.h. wenn man im Zustand $q_i$ die Eingabe $e$ ließt führt man $(q_j,k,r)$ aus mit $k\in\Gamma\land r\in\{R,L,N\}$ .man wechselt in Zustand $q_j,$ überschreibt die gelesene Zelle mit $k$ und bewegt sich in die Richtug $r$.
\end{enumerate}
\paragraph{k-Spur TM} Eine TM mit k-Spuren, die Spuren stehen unter eineander mit einem Kopf, jedoch können sich die Köpfe nich getrennt von eineander bewegen. Hier wird das Bandalphabet um $k-$dimensionale Vektoren erweitern.
\paragraph{k-Band TM } Eine Tm mit k-Bändern, ähnlich wie k-Spur TM nur das sich die Köpfe unabhäning von einander bewegen können. Die übergangsfuntkion $\delta$ wird zu $\delta:(Q/\{\bar{q}\}\times\Gamma^k\to Q\times\Gamma^k\times\{L,R,N\}^k)$ erweitert. Band 1 ist das Eingabe/Ausgabe Band.\\
Eine TM $M$ mit Rechenzeit $t(n)$ und Platzbedarf $s(n)$ auskommt, kann von einer (1-Band) TM $M'$ mit Zeitbedarf $O(t^2(n))$ und Platzbedarf $O(s(n))$ simuliert werden.
\end{definition}

\subsubsection{Konfiguration}

\paragraph{Konfiguration}
\begin{itemize}
\item Ist ein String $\alpha q\beta$ ,wobei $q\in Q \land \alpha,\beta \in\Gamma^*\to$ man ist im Zustand $q$ und auf dem Band steht $\alpha\beta$ eingerahmt von Blanks.
\end{itemize}
\paragraph{direkte Nachfolgekonfiguration}
\begin{itemize}
\item $\alpha'q\beta'$ heißt \underline{direkte} Nachfolgekonfig. wenn aus $\alpha q\beta$ in  einem Rechenschritt $\alpha'q\beta'$ wird. $\to\alpha q'\beta \vdash \alpha'q\beta'$
\end{itemize}
\paragraph{Nachfolgekonfiguration}
\begin{itemize}
\item $\alpha'' q''\beta''$ heißt Nachfolgekonfiguration von $\alpha q\beta$ wenn $\alpha'' q''\beta''$ in endlich vielen Rechenschritten erreicht werden kann $\to\alpha q\beta \vdash \alpha''q''\beta''$
\end{itemize}
\paragraph{Nachvollziehen einer Berechnung}
Um eine Rechnung nachzuvollziehen gibt man eine Abfolge von Konfigurationen an. z.B.:\begin{align*}
q_00110\vdash 0q_0110\vdash 01q_1 10\vdash 011q_1 0\vdash 0110q_0 B \vdash 0110\bar{q}1 
\end{align*}
\paragraph{TM-Berechenbare Funktionen}
- TM die für jede Eingabe terminiert berechnet eine totale Funktion.
- Das die Ausgabe beginnt unter dem Lese/Schreibkopf und wird nach  rechts durch den ersten Buchstaben begrenzt der nicht im Bandalphabet ist.
Da die meisten TM nicht immer terminieren, berechnen im allegmeinen eine Funktion $F:M\leadsto N$.
\paragraph{TM-Berechenbarkeit, Rekursivität}
Eine funktion heißt TM-berechenbar oder rekursiv, wenn es eine TM gibt, die auf jeder Eingabe $w$ terminiert mit der Ausgabe $f(w)$ .
\paragraph{partiel rekursiv} Eine Funktion $f$ heißt paritell rekursiv, wenn es eine TM M gibt die, genau auf den Wörtern $w\in Def(w)$ terminiert mit der Ausgabe $f(w)$.
\begin{definition}{TM-Entscheibarkeit}[Skript 1.17]\\
Eine Sprache $L$ heißt TM-Entscheidbar oder rekursiv, wenn es eine TM $M$ gibt, die auf allen eingaben $w\in\kleene$ stoppt und die Eingabe $w$ genau dann akzeptiert, wenn $w\in L$ und die Eingabe verwirft wenn $w\not\in L$.
\end{definition}
\begin{definition}{Aufzählungs-Turingmaschine}[Skript 1.18]
\begin{itemize}
\item TM der Form $(Q,\Sigma,\Gamma,B,q_0,bar{q},q_{out},\delta)$
\item $q_{out}$ deints als Ausgabezustand für die einzelnen Wörter, das an Kopfposition beginnt und vor dem ersten Symbol aus $\Gamma /\Sigma$ endet.
\end{itemize}
Eine Sprache $L$ heißt rekursiv aufzählbar, wenn es eine Aufzähler gibt, der die Spache $L$ enthält
\end{definition}

\subsection{Zusammenfassung Kaptiel 1}
\begin{itemize}
\item eine Funktion ist berechenbar wenn es eine TM gibt, die sie berechnet
\item eine Funktion ist total, wenn sie für alle Möglichen Eingaben definiert ist $f:M\to N$
\item eine Funktion ist partiell, wenn sie für eine Teilmenge der möglichen Eingaben definiert ist $f:M\leadsto N$
\item eine Sprache ist rekursiv, wenn es eine TM gibt die sie entscheidet\begin{itemize}
\item $1\forall w \in L$
\item $0\forall w\not\in L$
\end{itemize}
\item eine Sprache ist paritell rekursiv, wenn es eine TM gibt die auf alle ihren Wörtern hält und diese akzeptiert\begin{itemize}
\item $f_M(w)=v\forall w\in L$
\item $f_M(w)=\perp\forall w\not\in L$ ($\perp\widehat{=}$terminiert nicht bzw nicht definiert)
\end{itemize}
\item eine Sprache ist aufzählbar(=rekursiv aufzählbar), wenn es einen Aufzähler für sie gibt
\end{itemize}
\end{document}